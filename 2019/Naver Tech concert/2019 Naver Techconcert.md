# 2019 네이버 테크콘서트

## 소개
2019년 그린 팩토리에서 열린 네이버 테크콘서트에서 여러 발표들을 보고 들은 것을 메모한 문서입니다.

## Android Studio 설정 다시 한번 볼까요?
* 이번 세션은 라이브 시연으로 이루어진다.

* Quick List에서 단축키를 설정하여 자주 사용하는 기능을 단축키로 설정할 수 있다.

* notification란 Android Studio 내에서 오른 쪽 아래에 알람이 뜨는 것인데 Notifications에서 사용할 notification을 설정할 수도 있다.

* 또, read 박스에 체크 표시를 하면 그 notification을 android studio에서 알려준다.

* fill color에서는 파일들의 색상을 설정할 수 있는데 build variant에서 어떤 빌드를 선택하느냐에 따라 색상을 변경할 수 있게 한다. 이 기술은 시각적으로 실수를 줄일 수 있게 해준다.

* reformat 기능을 지원하여 코드의 정렬도 가능하고 editor의 code style 기능에서 kotlin에 들어가 file format에 들어가 체크를 해주면 알아서 kotlin style가 아닌 코드를 에러로 노출 시켜준다.

* 만약 자기 만의 스타일이 있다면 @formatter:off와 on으로 reformat 오류를 막을 수는 있다.

* 디버깅을 할 때는 Log를 사용하는 거보다 빨간 브레이크를 걸어서 디버깅을 하는 것이 좋고 조건을 넣고 싶다면 condition에 조건을 넣어서 디버깅을 진행할 수 있다.

* 우리가 String으로 json과 같은 언어를 정의할 때가 있는데 그 때 옵션 엔터를 눌러서 언어 형태를 android studio에서 인지할 수 있도록 바꿔줄 수 있고, 그렇게 하면 json의 형태로 볼 수 있다.

* 이 언어 형태를 정의할 때 나의 android studio에서만 적용되면 협업을 할 경우 헷갈릴 수가 있는데 @Language annotation을 통해서 어떤 언어인지 명시적으로 나타낼 수 있다.

* live templates에서 자신이 원하고 android studio에서 제공하는 templates을 단축키로 바로 적용할 수 있다. xm에서 유용하게 사용할 수 있을 것 같다.

* live templates처럼 파일을 templates으로 생성할 수 있는 기능인 File and Code Templates 기능이 있다.

* android studio를 킬 때 오른쪽 하단에 있는 설정에 들어가서 Memory Setting에 들어가면 android studio가 사용하는 memory를 설정할 수 있다.

* **정리**: android studio에서 제공하는 안드로이드 개발을 할 때 편리하고 유용한 기능들에 대한 발표였다. 
* **느낀점**: 정말 많은 꿀팁을 알려주셔서 이제 앞으로 편하게 안드로이드 개발을 할 수 있을 것 같다. 빨리 내 android studio에 적용하러 가야지.

## 예제에서는 알려주지 않는 Model이야기
* 모든 아키텍처에서는 Model이 빠지지 않고 거론이 된다. 이런 Model은 우리가 아는 것보다 훨씬 더 많은 역할을 담당하고 있다.

* MVP로 코드를 짤 때 Repository Pattern을 활용하는 것이 좋다.

* Repository Pattern은 데이터를 불러오는 로직을 분리시켜 관리하는 것이 목적이며, 하나의 Repository는 하나의 Domain을 담당하고 테스트를 할 떄 용이해진다.

* Repository는 Data를 불러오고 Presenter는 Repository를 호출해 그 불러온 데이터를 처리한다.

* Repository Pattern을 사용함으로서 Model은 Repsitory Pattern으로 추상화되었고 추상화를 통하여 테스트가 용이해지게 되었다.

* 기능이 추가되었다는 것은 비즈니스 로직이 추가 되었다는 뜻이다. 비즈니스 로직이란 유저의 행동에 따라 서비스에서 보여주고자하는 데이터를 가공하는 로직이다.

* 우리가 비즈니스 로직을 분리해야 하는 이유는 복잡한 화면일수록 Presentation의 코드가 커지게 되고, 그럴 수록 복잡성이 증대되고 유지보수성이 저하된다.

* 그래서 Presentation의 역할을 분리해줄 필요성이 생기고, Presentation에서 비즈니스 로직을 분리하고 Presentation에 집중해야 한다.

* Service Layer Pattern은 비즈니스 로직의 집합소 개념이고 재사용이 용이하지만 유지보수가 어려울 수가 있다.

* UseCase란 하나의 유저행동에 대한 서비스의 비즈니스 로직이 담겨있는 객체이며 서로에게 독립적이고 유지보수에 용이하다.

* UseCase는 하나의 비즈니스로직과 매칭되어야 한다는 것이 중요하다.

* Presentation에서 비즈니스 로직을 분리하면서 시스템이 복잡해져도 유연하게 대처할 수 있다.

* 이 구조에서 Exception Handling 하는 방법에 대해서 알아본다.

* Presentation에서 Exception Handling이 비즈니스로직인 이유는 Presenter에선 Http, 403 등에 대한 개념을 모르기 떄문이다. 

* 또한 유저의 행동에 따라 발생하는 예외 상황이기 때문에 비즈니스 로직으로 볼 수 있다.

* **정리**: Model에 대한 고찰 이야기이다. 점점 Model과 비즈니스 로직을 생각하면서 클린 아키텍처에 가까워지는 내용의 발표였다.
* **느낀점**: 발표의 김신입이라는 가상의 인물이 했던 것들이 내가 과거에 생각했던 것들과 매칭이 되서 재밌게 들었던 발표였다.

## 안드로이드 개발자 로드맵
1. 기본기란 DB, OS, Network, Data Structure 등이다. 이 것들을 연결해서 생각할 수 있어야 한다.

2. T자형 인재가 되어야 한다. Android Developer를 봐라.

3. xml 코드를 inflate하면 부풀어서 View가 된다.

4. View로 이해하라. View는 트리를 전위 순회하면서 깊이 탐색을 하는 방식이다.

5. 비동기할 때 Handler와 looper를 이해해라. 그러고 Rx와 Coroutine을 해라

6. 안드로이드 성능최적화를 하려면 UI 처리가 순차적으로 처리하게 해라.

7. 안드로이드 프레임워크를 공부해라.

8. 객체지향과 함수형을 잘아야 한다. SOLID를 공부하고 함수형 프로그래밍을 공부해라.

9. Clean Code나 Clean Archtecture 등 Best Practice를 공부해라.

10. 고인물이 되지 마라. 

* **정리**: T자형 안드로이드 개발자가 될 수 있는 로드 맵을 제시해주셨다. 레벨 단위로 나눠서 차근차근 나아갈 수 있도록 지도하는 발표였다.
* **느낀점**: 내가 과연 T자형 인재인가에 대해 많은 생각을 할 수 있는 발표였고 기본기에 대한 나의 생각을 일깨워준 발표였다.

## 나누고 쪼개지는 안드로이드
* 과거의 안드로이드가 목표를 했던 철칙들을 말씁하셨다.

* Process, Application Component, Project Treble, Project Mainline, Jetpack, Dynamic Delivery로 나누어지고 쪼개진다.

* 앞으로 안드로이드는 더 많은 플랫폼, 디바이스들이 나올 거고 더 많은 혁신들이 있을 것이다.

* **정리**: 앞으로 안드로이드의 미래에 대해 이야기하기 전 과거부터 안드로이드가 어떻게 발전해왔고 지금은 또 어떻게 발전하고 있는지 알아가면서 미래가 밝다는 것을 알려준 발표였다.
* **느낀점**: 발표에 집중해서 별로 메모는 못했는데 안드로이드가 나아가는 방향, 철학 등을 느낄 수 있는 발표였다.

## 무엇이든 물어 보세요. feat.모바일 개발, 기획, 디자인의 모든 것
* 마켓 리뷰는 계속 확인해야 하고 ANR에 대한 빠른 피드백이 필요하다.

* 그리고 사용자의 행동을 알 수 있는 Firebase와 같은 것들을 앱에 심어두면 좋다.

* IOS와 안드로이드 디자인할 때 가장 큰 차이점은 픽셀과 dp의 차이다.

* 네이버에서는 github 엔터프라이즈 버전을 사용해서 쓰고 있고 제플린도 사용 중이다. 기획은 모든 문서가 열릴 수 있는 것을 사용중이다.

* 기획자, 디자이너, 개발자가 함께 소통을 할 때 공감대를 형성하는 것이 좋다. 그리고 정확한 근거를 가지고 소통을 하는 것이 좋다.

* 개발자는 서비스에 대한 치열함을 가지고 있어야 한다. 유저가 원하는 것은 아무리 어려운 것이라도 꼭 해야한다.

* **정리**: 디자이너, 기획자, 개발자 세 분이서 질문을 받아 그 질문에 답하는 형식으로 진행된 발표였다. 함께 소통하는 법에 대해서 많이 배웠다.
* **느낀점**: 디자이너, 기획자, 개발자가 같이 한 질문에 대해서 대답을 하니까 개발자로서의 관점말고도 다양한 관점에서 문제 상황을 바라볼 수 있는 좋은 발표였다고 생각한다.

## 예제로 배우는 Android Camera2
* 카메라를 사용하는 방법 중 하나는 명시/암시적 인텐트를 사용하여 다른 어플리케이션을 호출하는 방법이 있다.

* 카메라2에서는 수동 조작 등 여러 기능을 제공한다. 여러개의 surfaces를 제공하는 것도 큰 이점이다.

* 카메라를 사용할 거면 매니페스트에 권한을 추가해야 하고 카메라 프리뷰로 TextureView를 사용한다.

* SurfaceTexture는 OpenGL ES 텍스쳐로써 이미지 스트림으로부터 프레임을 캡처한다.

* 카메라2에는 여러 용어가 있다. 

* CameraManager, CameraDevice, CameraCharacteristics, CmeraCaptureSession, CaptureRequest, CaptureResult 등이 있다.

* CameraManager 얻기, Surface 만들기, 캡쳐 세션 생성, 캡쳐리퀘스트 생성 등의 과정을 거치면서 만들어야 한다.

* CameraX라는 것이 있는데 유즈케이스 기반으로 되어 있고 Lifecycle을 알고 있어서 어렵고 복잡한 카메라를 쉽게 사용할 수 있다.

* **정리**: 제목 그대로 Android Camera2를 쓰는 법에 대한 발표였다.
* **느낀점**: 어떤 기능을 사용하는 법에 대한 발표를 들을 때 이해하느라 메모를 잘 못하는 편인데 한번 카메라 앱을 만들어보고 싶어지는 발표였다.

## 20분만에 만들어보는 라이브 방송 앱
* MediaCodec은 안드로이드에서 하드웨어/소프트웨어 코덱 사용을 위해 제공하는 API이다. 최소한 API 21을 사용하기를 권장한다.

* Codec은 클라이언트 사이에서 buffer로 데이터를 받아 전달하는 것이다.

* 송출 클라언트는 createByCodecName() 함수로 Codec을 만들고 surface를 설정하여 for 문으로 buffer를 넘긴다.

* 반면 소비 클라언트는 Codec을 통해 buffer를 받는다.

* Surface를 이용하는 이유는 Codec이 buffer를 넘겨서 데이터를 받는데 Surface 또한 buffer를 이용한 같은 방법으로 작동하기 때문이다.

* 또, 컬러 포맷에서 자유로워 질 수 있고, 소비자는 생산자가 생산한 모든 데이터를 받을 수 있는 것을 보장 받을 수 있다.

* RTMP는 어도비 독점 미디어 통신 규약인데 네트워크 전송을 위해 필요하다.

* RTMP는 구조적으로 심플하고 오버헤드가 적고 낮은 딜레이를 가지고 있다는 장점이 있는 반면 방화벽 문제가 있고, 오래돼서 일부 환경을 지원하지 않는 단점이 있다.

* 그래서 보통 송출단은 RTMP로 구성하고 시청단은 http단으로 구성한다.

* **정리**: MediaCodec을 이용한 라이브 방송 앱을 만드는 법에 대해 알아보는 발표였다.
* **느낀점**: 평소에 라이브 방송 앱은 어떻게 만들어지는지 몰랐는데 이제 알았으니까 정말 한번 만들어보고 싶어졌다.